import { Fn as Fn$1, MaybeRef, ConfigurableEventFilter, ConfigurableFlush, Pausable } from '@vueuse/shared';
export * from '@vueuse/shared';
import { Ref, UnwrapRef, ComputedRef, WritableComputedRef } from 'vue-demi';
import { Ref as Ref$1 } from 'vue-demi';

/**
 * Handle overlapping async evaluations.
 *
 * @param cancelCallback The provided callback is invoked when a re-evaluation of the computed value is triggered before the previous one finished
 */
declare type AsyncComputedOnCancel = (cancelCallback: Fn$1) => void;
/**
 * Additional options for asyncComputed
 *
 * @property lazy         Should value be evaluated lazily
 * @property evaluating   Ref passed to receive the updated of async evaluation
 */
declare type AsyncComputedOptions = {
    lazy?: Boolean;
    evaluating?: Ref<boolean>;
};
/**
 * Create an asynchronous computed dependency.
 *
 * @see   {@link https://vueuse.js.org/asyncComputed}
 * @param evaluationCallback     The promise-returning callback which generates the computed value
 * @param initialState           The initial state, used until the first evaluation finishes
 * @param optionsOrRef           Additional options or a ref passed to receive the updates of the async evaluation
 */
declare function asyncComputed<T>(evaluationCallback: (onCancel: AsyncComputedOnCancel) => T | Promise<T>, initialState?: T, optionsOrRef?: Ref<boolean> | AsyncComputedOptions): Ref<T>;

/**
 * Keep states in the global scope to be reusable across Vue instances.
 *
 * @see   {@link https://vueuse.js.org/createGlobalState}
 * @param stateFactory A factory function to create the state
 */
declare function createGlobalState<T extends object>(stateFactory: () => T): () => T;

interface ConfigurableWindow {
    window?: Window;
}
interface ConfigurableDocument {
    document?: Document;
}
interface ConfigurableNavigator {
    navigator?: Navigator;
}

declare const events: readonly ["mousedown", "touchstart"];
declare type EventType = WindowEventMap[(typeof events)[number]];
/**
 * Listen for clicks outside of an element.
 *
 * @see   {@link https://vueuse.js.org/onClickOutside}
 * @param target
 * @param handler
 * @param options
 */
declare function onClickOutside(target: MaybeRef<Element | null | undefined>, handler: (evt: EventType) => void, options?: ConfigurableWindow): (() => void) | undefined;

/**
 * Fires when users start typing on non-editable elements.
 *
 * @see   {@link https://vueuse.js.org/onStartTyping}
 * @param callback
 * @param options
 */
declare function onStartTyping(callback: (event: KeyboardEvent) => void, { document }?: ConfigurableDocument): void;

/**
 * Shorthand for binding ref to template element.
 *
 * @see   {@link https://vueuse.js.org/templateRef}
 * @param key
 * @param initialValue
 */
declare function templateRef<T extends Element | null>(key: string, initialValue?: T | null): Readonly<Ref<T>>;

/**
 * Reactive async state. Will not block your setup function and will triggers changes once
 * the promise is ready.
 *
 * @see   {@link https://vueuse.js.org/useAsyncState}
 * @param promise         The promise / async function to be resolved
 * @param initialState    The initial state, used until the first evaluation finishes
 * @param delay           Delay (ms)
 * @param catchFn         Error handling callback
 */
declare function useAsyncState<T>(promise: Promise<T>, initialState: T, delay?: number, catchFn?: (e: Error) => void): {
    state: Ref<UnwrapRef<T>>;
    ready: Ref<boolean>;
};

interface BatteryManager extends EventTarget {
    charging: boolean;
    chargingTime: number;
    dischargingTime: number;
    level: number;
}
/**
 * Reactive Battery Status API.
 *
 * @see   {@link https://vueuse.js.org/useBattery}
 * @param options
 */
declare function useBattery({ navigator }?: ConfigurableNavigator): {
    isSupported: boolean | undefined;
    charging: Ref<boolean>;
    chargingTime: Ref<number>;
    dischargingTime: Ref<number>;
    level: Ref<number>;
};

interface BrowserLocationState {
    trigger: string;
    state?: any;
    length?: number;
    hash?: string;
    host?: string;
    hostname?: string;
    href?: string;
    origin?: string;
    pathname?: string;
    port?: string;
    protocol?: string;
    search?: string;
}
/**
 * Reactive browser location.
 *
 * @see   {@link https://vueuse.js.org/useBrowserLocation}
 * @param options
 */
declare function useBrowserLocation({ window }?: ConfigurableWindow): Ref<{
    trigger: string;
    state?: any;
    length?: number | undefined;
    hash?: string | undefined;
    host?: string | undefined;
    hostname?: string | undefined;
    href?: string | undefined;
    origin?: string | undefined;
    pathname?: string | undefined;
    port?: string | undefined;
    protocol?: string | undefined;
    search?: string | undefined;
}>;

/**
 * Reactive Clipboard API.
 *
 * @see   {@link https://vueuse.js.org/useClipboard}
 * @param options
 */
declare function useClipboard({ navigator }?: ConfigurableNavigator): {
    isSupported: boolean | undefined;
    text: Ref<string>;
    copy: (txt: string) => Promise<void>;
};

/**
 * Manipulate CSS variables.
 *
 * @see   {@link https://vueuse.js.org/useCssVar}
 * @param prop
 * @param el
 * @param options
 */
declare function useCssVar(prop: string, el?: MaybeRef<HTMLElement | null>, { window }?: ConfigurableWindow): Ref<string>;

/**
 * Reactive DeviceLightEvent.
 *
 * @see   {@link https://vueuse.js.org/useDeviceLight}
 * @param options
 */
declare function useDeviceLight({ window }?: ConfigurableWindow): Ref<number | null>;

interface DeviceMotionOptions extends ConfigurableWindow, ConfigurableEventFilter {
}
/**
 * Reactive DeviceMotionEvent.
 *
 * @see   {@link https://vueuse.js.org/useDeviceMotion}
 * @param options
 */
declare function useDeviceMotion(options?: DeviceMotionOptions): {
    acceleration: Ref<DeviceMotionEventAcceleration | null>;
    accelerationIncludingGravity: Ref<DeviceMotionEventAcceleration | null>;
    rotationRate: Ref<DeviceMotionEventRotationRate | null>;
    interval: Ref<number>;
};

/**
 * Reactive DeviceOrientationEvent.
 *
 * @see   {@link https://vueuse.js.org/useDeviceOrientation}
 * @param options
 */
declare function useDeviceOrientation(options?: ConfigurableWindow): {
    isSupported: boolean;
    isAbsolute: Ref<boolean>;
    alpha: Ref<number | null>;
    beta: Ref<number | null>;
    gamma: Ref<number | null>;
};

/**
 * Reactively track `window.devicePixelRatio`.
 *
 * @see   {@link https://vueuse.js.org/useDevicePixelRatio}
 * @param options
 */
declare function useDevicePixelRatio({ window, }?: ConfigurableWindow): {
    pixelRatio: Ref<number>;
};

/**
 * Reactively track `document.visibilityState`.
 *
 * @see   {@link https://vueuse.js.org/useDocumentVisibility}
 * @param options
 */
declare function useDocumentVisibility({ document }?: ConfigurableDocument): Ref<VisibilityState>;

interface ResizeObserverSize {
    readonly inlineSize: number;
    readonly blockSize: number;
}
interface ResizeObserverEntry {
    readonly target: Element;
    readonly contentRect: DOMRectReadOnly;
    readonly borderBoxSize?: ReadonlyArray<ResizeObserverSize>;
    readonly contentBoxSize?: ReadonlyArray<ResizeObserverSize>;
    readonly devicePixelContentBoxSize?: ReadonlyArray<ResizeObserverSize>;
}
declare type ResizeObserverCallback = (entries: ReadonlyArray<ResizeObserverEntry>, observer: ResizeObserver) => void;
interface ResizeObserverOptions extends ConfigurableWindow {
    /**
     * Sets which box model the observer will observe changes to. Possible values
     * are `content-box` (the default), and `border-box`.
     *
     * @default 'content-box'
     */
    box?: 'content-box' | 'border-box';
}
declare class ResizeObserver {
    constructor(callback: ResizeObserverCallback);
    disconnect(): void;
    observe(target: Element, options?: ResizeObserverOptions): void;
    unobserve(target: Element): void;
}
/**
 * Reports changes to the dimensions of an Element's content or the border-box
 *
 * @see   {@link https://vueuse.js.org/useResizeObserver}
 * @param target
 * @param callback
 * @param options
 */
declare function useResizeObserver(target: MaybeRef<Element | null | undefined>, callback: ResizeObserverCallback, options?: ResizeObserverOptions): {
    isSupported: boolean | undefined;
    stop: () => void;
};

/**
 * Reactive size of an HTML element.
 *
 * @see   {@link https://vueuse.js.org/useElementSize}
 * @param target
 * @param callback
 * @param options
 */
declare function useElementBounding(target: MaybeRef<Element | null | undefined>, options?: ResizeObserverOptions): {
    x: Ref<number>;
    y: Ref<number>;
    top: Ref<number>;
    right: Ref<number>;
    bottom: Ref<number>;
    left: Ref<number>;
    width: Ref<number>;
    height: Ref<number>;
};

interface ElementSize {
    width: number;
    height: number;
}
/**
 * Reactive size of an HTML element.
 *
 * @see   {@link https://vueuse.js.org/useElementSize}
 * @param target
 * @param callback
 * @param options
 */
declare function useElementSize(target: MaybeRef<Element | null | undefined>, initialSize?: ElementSize, options?: ResizeObserverOptions): {
    width: Ref<number>;
    height: Ref<number>;
};

interface VisibilityScrollTargetOptions extends ConfigurableWindow {
    scrollTarget?: Ref<Element | null | undefined>;
}
/**
 * Tracks the visibility of an element within the viewport.
 *
 * @see   {@link https://vueuse.js.org/useElementVisibility}
 * @param element
 * @param options
 */
declare function useElementVisibility(element: Ref<Element | null | undefined>, { window, scrollTarget }?: VisibilityScrollTargetOptions): Ref<boolean>;

interface InferEventTarget<Events> {
    addEventListener(event: Events, fn?: any, options?: any): any;
    removeEventListener(event: Events, fn?: any, options?: any): any;
}
declare type WindowEventName = keyof WindowEventMap;
declare type DocumentEventName = keyof DocumentEventMap;
/**
 * Register using addEventListener on mounted, and removeEventListener automatically on unmounted.
 *
 * Overload 1: Omitted Window target
 *
 * @see   {@link https://vueuse.js.org/useEventListener}
 * @param event
 * @param listener
 * @param options
 */
declare function useEventListener<E extends keyof WindowEventMap>(event: E, listener: (this: Window, ev: WindowEventMap[E]) => any, options?: boolean | AddEventListenerOptions): Fn$1;
/**
 * Register using addEventListener on mounted, and removeEventListener automatically on unmounted.
 *
 * Overload 2: Explicitly Window target
 *
 * @see   {@link https://vueuse.js.org/useEventListener}
 * @param target
 * @param event
 * @param listener
 * @param options
 */
declare function useEventListener<E extends keyof WindowEventMap>(target: Window, event: E, listener: (this: Window, ev: WindowEventMap[E]) => any, options?: boolean | AddEventListenerOptions): Fn$1;
/**
 * Register using addEventListener on mounted, and removeEventListener automatically on unmounted.
 *
 * Overload 3: Explicitly Document target
 *
 * @see   {@link https://vueuse.js.org/useEventListener}
 * @param target
 * @param event
 * @param listener
 * @param options
 */
declare function useEventListener<E extends keyof DocumentEventMap>(target: Document, event: E, listener: (this: Document, ev: DocumentEventMap[E]) => any, options?: boolean | AddEventListenerOptions): Fn$1;
/**
 * Register using addEventListener on mounted, and removeEventListener automatically on unmounted.
 *
 * Overload 4: Custom event target with event type infer
 *
 * @see   {@link https://vueuse.js.org/useEventListener}
 * @param target
 * @param event
 * @param listener
 * @param options
 */
declare function useEventListener<Names extends string>(target: InferEventTarget<Names>, event: Names, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): Fn$1;
/**
 * Register using addEventListener on mounted, and removeEventListener automatically on unmounted.
 *
 * Overload 5: Custom event target fallback
 *
 * @see   {@link https://vueuse.js.org/useEventListener}
 * @param target
 * @param event
 * @param listener
 * @param options
 */
declare function useEventListener(target: EventTarget, event: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): Fn$1;

/**
 * Reactive wrapper for EventSource.
 *
 * @see   {@link https://vueuse.js.org/useEventSource}
 * @see   {@link https://developer.mozilla.org/en-US/docs/Web/API/EventSource/EventSource|EventSource}
 * @param url
 * @param events
 */
declare function useEventSource(url: string, events?: Array<string>): {
    eventSource: Ref<EventSource | null>;
    event: Ref<string | null>;
    data: Ref<string | null>;
    status: Ref<"OPEN" | "CONNECTING" | "CLOSED">;
    error: Ref<Event | null>;
    close: () => void;
};

interface FaviconOptions extends ConfigurableDocument {
    baseUrl?: string;
    rel?: string;
}
/**
 * Reactive favicon.
 *
 * @see   {@link https://vueuse.js.org/useFavicon}
 * @param newIcon
 * @param options
 */
declare function useFavicon(newIcon?: MaybeRef<string | null | undefined>, options?: FaviconOptions): Ref<string | null | undefined>;

/**
 * Reactive Fullscreen API.
 *
 * @see   {@link https://vueuse.js.org/useFullscreen}
 * @param target
 * @param options
 */
declare function useFullscreen(target?: MaybeRef<Element | null | undefined>, options?: ConfigurableDocument): {
    isSupported: boolean;
    isFullscreen: Ref<boolean>;
    enter: () => Promise<void>;
    exit: () => Promise<void>;
    toggle: () => Promise<void>;
};

interface GeolocationOptions extends Partial<PositionOptions>, ConfigurableNavigator {
}
/**
 * Reactive Geolocation API.
 *
 * @see   {@link https://vueuse.js.org/useGeolocation}
 * @param options
 */
declare function useGeolocation(options?: GeolocationOptions): {
    isSupported: boolean | undefined;
    coords: Ref<GeolocationCoordinates>;
    locatedAt: Ref<number | null>;
    error: Ref<{
        readonly code: number;
        readonly message: string;
        readonly PERMISSION_DENIED: number;
        readonly POSITION_UNAVAILABLE: number;
        readonly TIMEOUT: number;
    } | null>;
};

interface IdleOptions extends ConfigurableWindow, ConfigurableEventFilter {
    /**
     * Event names that listen to for detected user activity
     *
     * @default ['mousemove', 'mousedown', 'resize', 'keydown', 'touchstart', 'wheel']
     */
    events?: WindowEventName[];
    /**
     * Listen for document visibility change
     *
     * @default true
     */
    listenForVisibilityChange?: boolean;
    /**
     * Initial state of the ref idle
     *
     * @default false
     */
    initialState?: boolean;
}
/**
 * Tracks whether the user is being inactive.
 *
 * @see   {@link https://vueuse.js.org/useIdle}
 * @param timeout default to 1 minute
 * @param options IdleOptions
 */
declare function useIdle(timeout?: number, options?: IdleOptions): {
    idle: Ref<boolean>;
    lastActive: Ref<number>;
};

interface IntersectionObserverOptions extends ConfigurableWindow {
    /**
     * The Element or Document whose bounds are used as the bounding box when testing for intersection.
     */
    root?: MaybeRef<Element | null | undefined>;
    /**
     * A string which specifies a set of offsets to add to the root's bounding_box when calculating intersections.
     */
    rootMargin?: string;
    /**
     * Either a single number or an array of numbers between 0.0 and 1.
     */
    threshold?: number | number[];
}
/**
 * Detects that a target element's visibility.
 *
 * @see   {@link https://vueuse.js.org/useIntersectionObserver}
 * @param target
 * @param callback
 * @param options
 */
declare function useIntersectionObserver(target: MaybeRef<Element | null | undefined>, callback: IntersectionObserverCallback, options?: IntersectionObserverOptions): {
    isSupported: boolean | undefined;
    stop: () => void;
};

declare type StorageLike = Pick<Storage, 'getItem' | 'setItem' | 'removeItem'>;
interface StorageOptions extends ConfigurableEventFilter, ConfigurableWindow, ConfigurableFlush {
    /**
     * Watch for deep changes
     *
     * @default true
     */
    deep?: boolean;
    /**
     * Listen to storage changes, useful for multiple tabs application
     *
     * @default true
     */
    listenToStorageChanges?: boolean;
}
declare function useStorage(key: string, defaultValue: string, storage?: StorageLike, options?: StorageOptions): Ref<string>;
declare function useStorage(key: string, defaultValue: boolean, storage?: StorageLike, options?: StorageOptions): Ref<boolean>;
declare function useStorage(key: string, defaultValue: number, storage?: StorageLike, options?: StorageOptions): Ref<number>;
declare function useStorage<T>(key: string, defaultValue: T, storage?: StorageLike, options?: StorageOptions): Ref<T>;
declare function useStorage<T = unknown>(key: string, defaultValue: null, storage?: StorageLike, options?: StorageOptions): Ref<T>;

declare function useLocalStorage(key: string, defaultValue: string, options?: StorageOptions): Ref<string>;
declare function useLocalStorage(key: string, defaultValue: boolean, options?: StorageOptions): Ref<boolean>;
declare function useLocalStorage(key: string, defaultValue: number, options?: StorageOptions): Ref<number>;
declare function useLocalStorage<T>(key: string, defaultValue: T, options?: StorageOptions): Ref<T>;
declare function useLocalStorage<T = unknown>(key: string, defaultValue: null, options?: StorageOptions): Ref<T>;

interface UseRefHistoryRecord<T> {
    snapshot: T;
    timestamp: number;
}
declare type CloneFn<F, T = F> = (x: F) => T;
interface UseManualRefHistoryOptions<Raw, Serialized = Raw> {
    /**
     * Maximum number of history to be kept. Default to unlimited.
     */
    capacity?: number;
    /**
     * Clone when taking a snapshot, shortcut for dump: JSON.parse(JSON.stringify(value)).
     * Default to false
     *
     * @default false
     */
    clone?: boolean | CloneFn<Raw>;
    /**
     * Serialize data into the history
     */
    dump?: (v: Raw) => Serialized;
    /**
     * Deserialize data from the history
     */
    parse?: (v: Serialized) => Raw;
    /**
     * Deserialize data from the history
     */
    setSource?: (source: Ref<Raw>, v: Raw) => void;
}
interface UseManualRefHistoryReturn<Raw, Serialized> {
    /**
     * Bypassed tracking ref from the argument
     */
    source: Ref<Raw>;
    /**
     * An array of history records for undo, newest comes to first
     */
    history: Ref<UseRefHistoryRecord<Serialized>[]>;
    /**
    * Last history point, source can be different if paused
    */
    last: Ref<UseRefHistoryRecord<Serialized>>;
    /**
     * Same as 'history'
     */
    undoStack: Ref<UseRefHistoryRecord<Serialized>[]>;
    /**
     * Records array for redo
     */
    redoStack: Ref<UseRefHistoryRecord<Serialized>[]>;
    /**
     * A ref representing if undo is possible (non empty undoStack)
     */
    canUndo: Ref<boolean>;
    /**
     * A ref representing if redo is possible (non empty redoStack)
     */
    canRedo: Ref<boolean>;
    /**
     * Undo changes
     */
    undo(): void;
    /**
     * Redo changes
     */
    redo(): void;
    /**
     * Clear all the history
     */
    clear(): void;
    /**
     * Create new a new history record
     */
    commit(): void;
    /**
     * Reset ref's value with lastest history
     */
    reset(): void;
}
/**
 * Track the change history of a ref, also provides undo and redo functionality.
 *
 * @see   {@link https://vueuse.js.org/useManualRefHistory}
 * @param source
 * @param options
 */
declare function useManualRefHistory<Raw, Serialized = Raw>(source: Ref<Raw>, options?: UseManualRefHistoryOptions<Raw, Serialized>): UseManualRefHistoryReturn<Raw, Serialized>;

/**
 * Reactive Media Query.
 *
 * @see   {@link https://vueuse.js.org/useMediaQuery}
 * @param query
 * @param options
 */
declare function useMediaQuery(query: string, options?: ConfigurableWindow): Ref<boolean>;

interface MouseOptions extends ConfigurableWindow {
    /**
     * Listen to `touchmove` events
     *
     * @default true
     */
    touch?: boolean;
    /**
     * Reset to initial value when `touchend` event fired
     *
     * @default false
     */
    resetOnTouchEnds?: boolean;
    /**
     * Initial values
     */
    initialValue?: {
        x: number;
        y: number;
    };
}
declare type MouseSourceType = 'mouse' | 'touch' | null;
/**
 * Reactive mouse position.
 *
 * @see   {@link https://vueuse.js.org/useMouse}
 * @param options
 */
declare function useMouse(options?: MouseOptions): {
    x: Ref<number>;
    y: Ref<number>;
    sourceType: Ref<MouseSourceType>;
};

interface MouseInElementOptions extends MouseOptions {
    handleOutside?: boolean;
}
/**
 * Reactive mouse position related to an element.
 *
 * @see   {@link https://vueuse.js.org/useMouseInElement}
 * @param target
 * @param options
 */
declare function useMouseInElement(target?: MaybeRef<Element | null | undefined>, options?: MouseInElementOptions): {
    x: Ref<number>;
    y: Ref<number>;
    sourceType: Ref<MouseSourceType>;
    elementX: Ref<number>;
    elementY: Ref<number>;
    elementPositionX: Ref<number>;
    elementPositionY: Ref<number>;
    elementHeight: Ref<number>;
    elementWidth: Ref<number>;
    isOutside: Ref<boolean>;
    stop: () => void;
};

interface MousePressedOptions extends ConfigurableWindow {
    /**
     * Listen to `touchstart` `touchend` events
     *
     * @default true
     */
    touch?: boolean;
    /**
     * Initial values
     *
     * @default false
     */
    initialValue?: boolean;
    /**
     * Element target to be capture the click
     */
    target?: MaybeRef<Element | null | undefined>;
}
/**
 * Reactive mouse position.
 *
 * @see   {@link https://vueuse.js.org/useMousePressed}
 * @param options
 */
declare function useMousePressed(options?: MousePressedOptions): {
    pressed: Ref<boolean>;
    sourceType: Ref<MouseSourceType>;
};

interface MutationObserverOptions extends MutationObserverInit, ConfigurableWindow {
}
/**
 * Watch for changes being made to the DOM tree.
 *
 * @see   {@link https://vueuse.js.org/useMutationObserver}
 * @see   {@link https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver|MutationObserver MDN}
 * @param el
 * @param callback
 * @param options
 */
declare function useMutationObserver(el: MaybeRef<HTMLElement | null | undefined>, callback: MutationCallback, options?: MutationObserverOptions): {
    isSupported: boolean | undefined;
    stop: () => void;
};

declare type NetworkType = 'bluetooth' | 'cellular' | 'ethernet' | 'none' | 'wifi' | 'wimax' | 'other' | 'unknown';
declare type NetworkEffectiveType = 'slow-2g' | '2g' | '3g' | '4g' | undefined;
interface NetworkState {
    isSupported: boolean;
    /**
     * If the user is currently connected.
     */
    isOnline: Ref<boolean>;
    /**
     * The time since the user was last connected.
     */
    offlineAt: Ref<number | undefined>;
    /**
     * The download speed in Mbps.
     */
    downlink: Ref<number | undefined>;
    /**
     * The max reachable download speed in Mbps.
     */
    downlinkMax: Ref<number | undefined>;
    /**
    * The detected effective speed type.
    */
    effectiveType: Ref<NetworkEffectiveType | undefined>;
    /**
     * If the user activated data saver mode.
     */
    saveData: Ref<boolean | undefined>;
    /**
     * The detected connection/network type.
     */
    type: Ref<NetworkType>;
}
/**
 * Reactive Network status.
 *
 * @see   {@link https://vueuse.js.org/useNetwork}
 * @param options
 */
declare function useNetwork(options?: ConfigurableWindow): NetworkState;

/**
 * Reactive online state.
 *
 * @see   {@link https://vueuse.js.org/useOnline}
 * @param options
 */
declare function useOnline(options?: ConfigurableWindow): Ref$1<boolean>;

/**
 * Reactive state to show whether mouse leaves the page.
 *
 * @see   {@link https://vueuse.js.org/usePageLeave}
 * @param options
 */
declare function usePageLeave(options?: ConfigurableWindow): Ref<boolean>;

interface ParallaxOptions extends ConfigurableWindow {
    deviceOrientationTiltAdjust?: (i: number) => number;
    deviceOrientationRollAdjust?: (i: number) => number;
    mouseTiltAdjust?: (i: number) => number;
    mouseRollAdjust?: (i: number) => number;
}
interface ParallaxReturn {
    /**
     * Roll value. Scaled to `-0.5 ~ 0.5`
     */
    roll: ComputedRef<number>;
    /**
     * Tilt value. Scaled to `-0.5 ~ 0.5`
     */
    tilt: ComputedRef<number>;
    /**
     * Sensor source, can be `mouse` or `deviceOrientation`
     */
    source: ComputedRef<'deviceOrientation' | 'mouse'>;
}
/**
 * Create parallax effect easily. It uses `useDeviceOrientation` and fallback to `useMouse`
 * if orientation is not supported.
 *
 * @param target
 * @param options
 */
declare function useParallax(target: MaybeRef<Element | null | undefined>, options?: ParallaxOptions): ParallaxReturn;

declare type DescriptorNamePolyfill = 'clipboard-read' | 'clipboard-write';
declare type GeneralPermissionDescriptor = PermissionDescriptor | DevicePermissionDescriptor | MidiPermissionDescriptor | PushPermissionDescriptor | {
    name: DescriptorNamePolyfill;
};
/**
 * Reactive Permissions API.
 *
 * @see   {@link https://vueuse.js.org/usePermission}
 * @param permissionDesc
 * @param options
 */
declare function usePermission(permissionDesc: GeneralPermissionDescriptor | GeneralPermissionDescriptor['name'], options?: ConfigurableNavigator): Ref<"" | "denied" | "granted" | "prompt">;

declare type ColorSchemeType = 'dark' | 'light' | 'no-preference';
/**
 * Reactive prefers-color-scheme media query.
 *
 * @see   {@link https://vueuse.js.org/usePreferredColorScheme}
 * @param [options]
 */
declare function usePreferredColorScheme(options?: ConfigurableWindow): ComputedRef<ColorSchemeType>;

/**
 * Reactive dark theme preference.
 *
 * @see   {@link https://vueuse.js.org/usePreferredDark}
 * @param [options]
 */
declare function usePreferredDark(options?: ConfigurableWindow): Ref$1<boolean>;

/**
 * Reactive Navigator Languages.
 *
 * @see   {@link https://vueuse.js.org/usePreferredLanguages}
 * @param options
 */
declare function usePreferredLanguages(options?: ConfigurableWindow): Ref<readonly string[]>;

interface RafFnOptions extends ConfigurableWindow {
    /**
     * Start the requestAnimationFrame loop immediately on creation
     *
     * @default true
     */
    immediate?: boolean;
}
interface RafFnReturn extends Pausable {
    /**
     * @deprecated use pause() instead
     */
    stop: Fn$1;
    /**
     * @deprecated use resume() instead
     */
    start: Fn$1;
}
/**
 * Call function on every `requestAnimationFrame`. With controls of pausing and resuming.
 *
 * @see   {@link https://vueuse.js.org/useRafFn}
 * @param fn
 * @param options
 */
declare function useRafFn(fn: Fn$1, options?: RafFnOptions): RafFnReturn;

interface UseRefHistoryOptions<Raw, Serialized = Raw> {
    /**
     * Watch for deep changes, default to false
     *
     * When set to true, it will also create clones for values store in the history
     *
     * @default false
     */
    deep?: boolean;
    /**
     * The flush option allows for greater control over the timing of a history point, default to 'pre'
     *
     * Possible values: 'pre', 'post', 'sync'
     * It works in the same way as the flush option in watch and watch effect in vue reactivity
     *
     * @default 'pre'
     */
    flush?: 'pre' | 'post' | 'sync';
    /**
     * Maximum number of history to be kept. Default to unlimited.
     */
    capacity?: number;
    /**
     * Clone when taking a snapshot, shortcut for dump: JSON.parse(JSON.stringify(value)).
     * Default to false
     *
     * @default false
     */
    clone?: boolean | CloneFn<Raw>;
    /**
     * Serialize data into the history
     */
    dump?: (v: Raw) => Serialized;
    /**
     * Deserialize data from the history
     */
    parse?: (v: Serialized) => Raw;
}
interface UseRefHistoryReturn<Raw, Serialized> {
    /**
     * Bypassed tracking ref from the argument
     */
    source: Ref<Raw>;
    /**
     * An array of history records for undo, newest comes to first
     */
    history: Ref<UseRefHistoryRecord<Serialized>[]>;
    /**
    * Last history point, source can be different if paused
    */
    last: Ref<UseRefHistoryRecord<Serialized>>;
    /**
     * Same as 'history'
     */
    undoStack: Ref<UseRefHistoryRecord<Serialized>[]>;
    /**
     * Records array for redo
     */
    redoStack: Ref<UseRefHistoryRecord<Serialized>[]>;
    /**
     * A ref representing if the tracking is enabled
     */
    isTracking: Ref<boolean>;
    /**
     * A ref representing if undo is possible (non empty undoStack)
     */
    canUndo: Ref<boolean>;
    /**
     * A ref representing if redo is possible (non empty redoStack)
     */
    canRedo: Ref<boolean>;
    /**
     * Undo changes
     */
    undo(): void;
    /**
     * Redo changes
     */
    redo(): void;
    /**
     * Clear all the history
     */
    clear(): void;
    /**
     * Pause change tracking
     */
    pause(): void;
    /**
     * Resume change tracking
     *
     * @param [commit] if true, a history record will be create after resuming
     */
    resume(commit?: boolean): void;
    /**
     * Create new a new history record
     */
    commit(): void;
    /**
     * Reset ref's value with lastest history
     */
    reset(): void;
    /**
     * A sugar for auto pause and auto resuming within a function scope
     *
     * @param fn
     */
    batch(fn: (cancel: Fn$1) => void): void;
    /**
     * Clear the data and stop the watch
     */
    dispose(): void;
}
/**
 * Track the change history of a ref, also provides undo and redo functionality.
 *
 * @see   {@link https://vueuse.js.org/useRefHistory}
 * @param source
 * @param options
 */
declare function useRefHistory<Raw, Serialized = Raw>(source: Ref<Raw>, options?: UseRefHistoryOptions<Raw, Serialized>): UseRefHistoryReturn<Raw, Serialized>;

interface UseScriptTagOptions extends ConfigurableDocument {
    /**
     * Load the script immediately
     *
     * @default true
     */
    immediate?: boolean;
    /**
     * Add `async` attribute to the script tag
     *
     * @default true
     */
    async?: boolean;
    /**
     * Script type
     *
     * @default 'text/javascript'
     */
    type?: string;
    /**
     * Manual controls the timing of loading and unloading
     *
     * @default false
     */
    manual?: boolean;
    crossOrigin?: 'anonymous' | 'use-credentials';
    referrerPolicy?: 'no-referrer' | 'no-referrer-when-downgrade' | 'origin' | 'origin-when-cross-origin' | 'same-origin' | 'strict-origin' | 'strict-origin-when-cross-origin' | 'unsafe-url';
    noModule?: boolean;
    defer?: boolean;
}
/**
 * Async script tag loading.
 *
 * @see   {@link https://vueuse.js.org/useScriptTag}
 * @param src
 */
declare function useScriptTag(src: MaybeRef<string>, onLoaded?: (el: HTMLScriptElement) => void, options?: UseScriptTagOptions): {
    scriptTag: Ref<HTMLScriptElement | null>;
    load: (waitForScriptLoad?: boolean) => Promise<HTMLScriptElement | boolean>;
    unload: () => void;
};

declare function useSessionStorage(key: string, defaultValue: string, options?: StorageOptions): Ref<string>;
declare function useSessionStorage(key: string, defaultValue: boolean, options?: StorageOptions): Ref<boolean>;
declare function useSessionStorage(key: string, defaultValue: number, options?: StorageOptions): Ref<number>;
declare function useSessionStorage<T>(key: string, defaultValue: T, options?: StorageOptions): Ref<T>;
declare function useSessionStorage<T = unknown>(key: string, defaultValue: null, options?: StorageOptions): Ref<T>;

interface ShareOptions {
    title?: string;
    files?: File[];
    text?: string;
    url?: string;
}
/**
 * Reactive Web Share API.
 *
 * @use   {@link https://vueuse.js.org/useShare}
 * @param shareOptions
 * @param options
 */
declare function useShare(shareOptions?: MaybeRef<ShareOptions>, options?: ConfigurableNavigator): {
    isSupported: boolean;
    share: (overrideOptions?: MaybeRef<ShareOptions>) => Promise<void>;
};

interface SpeechRecognitionOptions extends ConfigurableWindow {
    /**
     * Controls whether continuous results are returned for each recognition, or only a single result.
     *
     * @default true
     */
    continuous?: boolean;
    /**
     * Controls whether interim results should be returned (true) or not (false.) Interim results are results that are not yet final
     *
     * @default true
     */
    interimResults?: boolean;
    /**
     * Langauge for SpeechRecognition
     *
     * @default 'en-US'
     */
    lang?: string;
}
/**
 * Reactive SpeechRecognition.
 *
 * @see   {@link https://vueuse.js.org/useSpeechRecognition}
 * @see   {@link https://developer.mozilla.org/en-US/docs/Web/API/SpeechRecognition|SpeechRecognition}
 * @param options
 */
declare function useSpeechRecognition(options?: SpeechRecognitionOptions): {
    isSupported: boolean;
    isListening: Ref<boolean>;
    isFinal: Ref<boolean>;
    recognition: SpeechRecognition | undefined;
    result: Ref<string>;
    error: Ref<null>;
    toggle: (value?: boolean) => void;
    start: () => void;
    stop: () => void;
};

declare type Fn = () => void;

interface TimestampOptions {
    /**
     * Offset value adding to the value
     *
     * @default 0
     */
    offset?: number;
}
/**
 * Reactive current timestamp.
 *
 * @see   {@link https://vueuse.js.org/useTimestamp}
 * @param options
 */
declare function useTimestamp(options?: TimestampOptions): {
    stop: Fn;
    start: Fn;
    isActive: Ref<boolean>;
    pause: Fn;
    resume: Fn;
    timestamp: Ref<number>;
};

/**
 * Reactive document title.
 *
 * @see   {@link https://vueuse.js.org/useTitle}
 * @param newTitle
 * @param options
 */
declare function useTitle(newTitle?: MaybeRef<string | null | undefined>, { document }?: ConfigurableDocument): Ref<string | null | undefined>;

/**
 * Cubic bezier points
 */
declare type CubicBezierPoints = [number, number, number, number];
/**
 * Easing function
 */
declare type EasingFunction = (n: number) => number;
/**
 * Transition options
 */
interface TransitionOptions {
    duration?: MaybeRef<number>;
    onFinished?: () => unknown;
    onStarted?: () => unknown;
    transition?: MaybeRef<EasingFunction | CubicBezierPoints>;
}
/**
 * Common transitions
 *
 * @see   {@link https://easings.net}
 */
declare const TransitionPresets: Record<string, CubicBezierPoints>;
/**
 * Transition between values.
 *
 * @see   {@link https://vueuse.js.org/useTransition}
 * @param source
 * @param options
 */
declare function useTransition(source: Ref<number>, options?: TransitionOptions): Ref<number>;

declare type UrlParams = Record<string, string[] | string>;
/**
 * Reactive URLSearchParams
 *
 * @see   {@link https://vueuse.js.org/useUrlSearchParams}
 * @param mode
 * @param options
 */
declare function useUrlSearchParams<T extends Record<string, any> = UrlParams>(mode?: 'history' | 'hash', options?: ConfigurableWindow): T;

/**
 * Shorthand for v-model binding, props + emit -> ref
 *
 * @see   {@link https://vueuse.js.org/useVModel}
 * @param props
 * @param key
 * @param emit
 */
declare function useVModel<P extends object, K extends keyof P>(props: P, key: K, emit?: (name: string, value: any) => void): WritableComputedRef<P[K]>;

declare type WebSocketStatus = 'OPEN' | 'CONNECTING' | 'CLOSING' | 'CLOSED';
/**
 * Reactive simple WebSocket client.
 *
 * @see   {@link https://vueuse.js.org/useWebSocket}
 * @param url
 */
declare function useWebSocket(url: string): {
    data: Ref<any>;
    state: Ref<WebSocketStatus>;
    close: (code?: number | undefined, reason?: string | undefined) => void;
    send: (data: string | Blob | ArrayBuffer | SharedArrayBuffer | ArrayBufferView) => void;
    ws: WebSocket;
};

/**
 * Simple Web Workers registration and communication.
 *
 * @see   {@link https://vueuse.js.org/useWebWorker}
 * @param url
 */
declare function useWebWorker(url: string): {
    data: Ref<any>;
    post: {
        (message: any, transfer: Transferable[]): void;
        (message: any, options?: PostMessageOptions | undefined): void;
    };
    terminate: () => void;
};

declare type WebWorkerStatus = 'PENDING' | 'SUCCESS' | 'RUNNING' | 'ERROR' | 'TIMEOUT_EXPIRED';
interface WebWorkerOptions extends ConfigurableWindow {
    timeout?: number;
    dependencies?: string[];
}
/**
 * Run expensive function without blocking the UI, using a simple syntax that makes use of Promise.
 *
 * @see   {@link https://vueuse.js.org/useWebWorkerFn}
 * @param fn
 * @param options
 */
declare const useWebWorkerFn: <T extends (...fnArgs: any[]) => any>(fn: T, { dependencies, timeout, window, }?: WebWorkerOptions) => {
    workerFn: (...fnArgs: Parameters<T>) => Promise<ReturnType<T>>;
    workerStatus: Ref<WebWorkerStatus>;
    workerTerminate: (status?: WebWorkerStatus) => void;
};

/**
 * Reactive window scroll.
 *
 * @see   {@link https://vueuse.js.org/useWindowScroll}
 * @param options
 */
declare function useWindowScroll({ window }?: ConfigurableWindow): {
    x: Ref<number>;
    y: Ref<number>;
};

interface WindowSizeOptions extends ConfigurableWindow {
    initialWidth?: number;
    initialHeight?: number;
}
/**
 * Reactive window size.
 *
 * @see   {@link https://vueuse.js.org/useWindowSize}
 * @param options
 */
declare function useWindowSize({ window, initialWidth, initialHeight }?: WindowSizeOptions): {
    width: Ref<number>;
    height: Ref<number>;
};

export { AsyncComputedOnCancel, AsyncComputedOptions, BatteryManager, BrowserLocationState, CloneFn, ColorSchemeType, DocumentEventName, ElementSize, FaviconOptions, GeneralPermissionDescriptor, GeolocationOptions, IdleOptions, IntersectionObserverOptions, MouseInElementOptions, MouseOptions, MousePressedOptions, MouseSourceType, MutationObserverOptions, NetworkEffectiveType, NetworkState, NetworkType, ParallaxOptions, ParallaxReturn, RafFnOptions, RafFnReturn, ResizeObserverCallback, ResizeObserverEntry, ResizeObserverOptions, ResizeObserverSize, ShareOptions, SpeechRecognitionOptions, StorageLike, StorageOptions, TimestampOptions, TransitionPresets, UrlParams, UseManualRefHistoryOptions, UseManualRefHistoryReturn, UseRefHistoryOptions, UseRefHistoryRecord, UseRefHistoryReturn, UseScriptTagOptions, VisibilityScrollTargetOptions, WebSocketStatus, WebWorkerOptions, WebWorkerStatus, WindowEventName, WindowSizeOptions, asyncComputed, createGlobalState, onClickOutside, onStartTyping, templateRef, useAsyncState, useBattery, useBrowserLocation, useClipboard, useCssVar, useDeviceLight, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDocumentVisibility, useElementBounding, useElementSize, useElementVisibility, useEventListener, useEventSource, useFavicon, useFullscreen, useGeolocation, useIdle, useIntersectionObserver, useLocalStorage, useManualRefHistory, useMediaQuery, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNetwork, useOnline, usePageLeave, useParallax, usePermission, usePreferredColorScheme, usePreferredDark, usePreferredLanguages, useRafFn, useRefHistory, useResizeObserver, useScriptTag, useSessionStorage, useShare, useSpeechRecognition, useStorage, useTimestamp, useTitle, useTransition, useUrlSearchParams, useVModel, useWebSocket, useWebWorker, useWebWorkerFn, useWindowScroll, useWindowSize };
